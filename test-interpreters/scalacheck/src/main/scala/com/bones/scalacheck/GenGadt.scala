package com.bones.scalacheck

import com.bones.data.values.{DoubleData, ScalaCoreValue, StringData}
import com.bones.data.{KeyDefinition, _}
import com.bones.scalacheck.values.ScalacheckScalaCoreInterpreter
import com.bones.validation.ValidationDefinition.StringValidation.{MaxLength, Trimmed}
import com.bones.validation.ValidationDefinition.ValidationOp
import org.scalacheck.Gen
import shapeless.ops.hlist.IsHCons
import shapeless.{::, HList, Nat, Succ}

/**
  * GenGadt can randomly generate a Schema.  Currently, only supports ScalaCoreValue algebra.
  */
trait GenGadt {

  type ALG[A] = ScalaCoreValue[A]

  def genMaxStringLength: Gen[MaxLength] =
    for {
      len <- Gen.choose(0, 5000)
    } yield MaxLength(len)

  def genTrimmed: Gen[Trimmed.type] = Gen.const(Trimmed)

  def genStringValidation: Gen[ValidationOp[String]] =
    Gen.oneOf(genMaxStringLength, genTrimmed)

  def genStringData: Gen[StringData] =
    for {
      validation <- genStringValidation
    } yield StringData(List(validation))

  def genDoubleData: Gen[DoubleData] = Gen.const(DoubleData(List.empty))

  def genKeys = Gen.oneOf(ScalacheckScalaCoreInterpreter.loremIpsumWords)

  val types: Gen[String] = Gen.oneOf("String", "Double", "Object")
  val false90Percent: Gen[Boolean] = Gen.frequency((1, true), (9, false))

  def genHListValue(): Gen[KvpCollectionValue[String, ALG, _]] =
    for {
      strHead <- genStringData
      t <- types
      hList <- nextGen(false, "first", strHead, KvpNil[String, ALG](), t)
    } yield KvpCollectionValue(hList, "TestType", List.empty)

  def nextGen[A, H <: HList, N <: Nat](
    done: Boolean,
    key: String,
    newHead: ALG[A],
    tail: KvpHListCollection[String, ALG, H, N],
    nextType: String
  ): Gen[KvpHListCollection[String, ALG, _ <: HList, _ <: Nat]] = {

    val isHCons = implicitly[IsHCons.Aux[A :: H, A, H]]
    val thisValue: KvpHListCollection[String, ALG, A :: H, Succ[N]] = KvpSingleValueHead(
      Left(
        KeyDefinition[String, ALG, A](
          key,
          Right(newHead),
          "TestType",
          Some("Schema generated by Gen GADT"),
          None)),
      "TestType",
      List.empty,
      tail,
      isHCons)
    if (done) {
      Gen.const(thisValue)
    } else {
      nextType match {
        case "String" =>
          genStringData.flatMap(sd => {
            genKvpSingleValueHead(sd, thisValue)
          })
        case "Double" =>
          genDoubleData.flatMap(dd => {
            genKvpSingleValueHead(dd, thisValue)
          })
        case "Object" => {
          genKvpSingleValueHead(StringData(List.empty), KvpNil[String, ALG]()).flatMap(kvpHList => {
            val next = KvpCollectionValue(kvpHList, "TestType", List.empty)
            genKeys.map(objKey => {
              KvpSingleValueHead(
                Left(
                  KeyDefinition(
                    key,
                    Left(next),
                    "TestType",
                    Some("Schema generated by Gen GADT"),
                    None)),
                "TestType",
                List.empty,
                thisValue,
                null)
            })
          })
        }
      }
    }
  }

  def genKvpSingleValueHead[A, H <: HList, N <: Nat](
    newHead: ALG[A],
    tail: KvpHListCollection[String, ALG, H, N]
  ): Gen[KvpHListCollection[String, ALG, _ <: HList, _ <: Nat]] = {
    for {
      key <- genKeys
      t <- types
      done <- false90Percent
      next <- {
        nextGen(done, key, newHead, tail, t)
      }
    } yield {
      next
    }
  }
}
